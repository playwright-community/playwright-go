diff --git a/docs/src/api/class-apirequest.md b/docs/src/api/class-apirequest.md
index 164de27b2..a19100289 100644
--- a/docs/src/api/class-apirequest.md
+++ b/docs/src/api/class-apirequest.md
@@ -45,7 +45,7 @@ Methods like [`method: APIRequestContext.get`] take the base URL into considerat
 
 ### option: APIRequest.newContext.storageState
 * since: v1.16
-* langs: js, python
+* langs: js, python, go
 - `storageState` <[path]|[Object]>
   - `cookies` <[Array]<[Object]>>
     - `name` <[string]>
diff --git a/docs/src/api/class-apirequestcontext.md b/docs/src/api/class-apirequestcontext.md
index 4a5debdb1..61b673ed5 100644
--- a/docs/src/api/class-apirequestcontext.md
+++ b/docs/src/api/class-apirequestcontext.md
@@ -153,18 +153,27 @@ context cookies from the response. The method will automatically follow redirect
 ### option: APIRequestContext.delete.data = %%-js-python-csharp-fetch-option-data-%%
 * since: v1.17
 
+### option: APIRequestContext.delete.data = %%-go-fetch-option-data-%%
+* since: v1.17
+
 ### option: APIRequestContext.delete.form = %%-js-python-fetch-option-form-%%
 * since: v1.17
 
 ### option: APIRequestContext.delete.form = %%-csharp-fetch-option-form-%%
 * since: v1.17
 
+### option: APIRequestContext.delete.form = %%-go-fetch-option-form-%%
+* since: v1.17
+
 ### option: APIRequestContext.delete.multipart = %%-js-python-fetch-option-multipart-%%
 * since: v1.17
 
 ### option: APIRequestContext.delete.multipart = %%-csharp-fetch-option-multipart-%%
 * since: v1.17
 
+### option: APIRequestContext.delete.multipart = %%-go-fetch-option-multipart-%%
+* since: v1.17
+
 ### option: APIRequestContext.delete.timeout = %%-js-python-csharp-fetch-option-timeout-%%
 * since: v1.16
 
@@ -307,7 +316,7 @@ Target URL or Request to get all parameters from.
 
 ### option: APIRequestContext.fetch.method
 * since: v1.16
-* langs: js, python, csharp
+* langs: js, python, csharp, go
 - `method` <[string]>
 
 If set changes the fetch method (e.g. [PUT](https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/PUT) or
@@ -319,18 +328,27 @@ If set changes the fetch method (e.g. [PUT](https://developer.mozilla.org/en-US/
 ### option: APIRequestContext.fetch.data = %%-js-python-csharp-fetch-option-data-%%
 * since: v1.16
 
+### option: APIRequestContext.fetch.data = %%-go-fetch-option-data-%%
+* since: v1.16
+
 ### option: APIRequestContext.fetch.form = %%-js-python-fetch-option-form-%%
 * since: v1.16
 
 ### option: APIRequestContext.fetch.form = %%-csharp-fetch-option-form-%%
 * since: v1.16
 
+### option: APIRequestContext.fetch.form = %%-go-fetch-option-form-%%
+* since: v1.16
+
 ### option: APIRequestContext.fetch.multipart = %%-js-python-fetch-option-multipart-%%
 * since: v1.16
 
 ### option: APIRequestContext.fetch.multipart = %%-csharp-fetch-option-multipart-%%
 * since: v1.16
 
+### option: APIRequestContext.fetch.multipart = %%-go-fetch-option-multipart-%%
+* since: v1.16
+
 ### option: APIRequestContext.fetch.timeout = %%-js-python-csharp-fetch-option-timeout-%%
 * since: v1.16
 
@@ -405,18 +423,27 @@ await request.GetAsync("https://example.com/api/getText", new() { Params = param
 ### option: APIRequestContext.get.data = %%-js-python-csharp-fetch-option-data-%%
 * since: v1.26
 
+### option: APIRequestContext.get.data = %%-go-fetch-option-data-%%
+* since: v1.26
+
 ### option: APIRequestContext.get.form = %%-js-python-fetch-option-form-%%
 * since: v1.26
 
 ### option: APIRequestContext.get.form = %%-csharp-fetch-option-form-%%
 * since: v1.26
 
+### option: APIRequestContext.get.form = %%-go-fetch-option-form-%%
+* since: v1.26
+
 ### option: APIRequestContext.get.multipart = %%-js-python-fetch-option-multipart-%%
 * since: v1.26
 
 ### option: APIRequestContext.get.multipart = %%-csharp-fetch-option-multipart-%%
 * since: v1.26
 
+### option: APIRequestContext.get.multipart = %%-go-fetch-option-multipart-%%
+* since: v1.26
+
 ### option: APIRequestContext.get.timeout = %%-js-python-csharp-fetch-option-timeout-%%
 * since: v1.16
 
@@ -455,18 +482,27 @@ context cookies from the response. The method will automatically follow redirect
 ### option: APIRequestContext.head.data = %%-js-python-csharp-fetch-option-data-%%
 * since: v1.26
 
+### option: APIRequestContext.head.data = %%-go-fetch-option-data-%%
+* since: v1.26
+
 ### option: APIRequestContext.head.form = %%-js-python-fetch-option-form-%%
 * since: v1.26
 
 ### option: APIRequestContext.head.form = %%-csharp-fetch-option-form-%%
 * since: v1.26
 
+### option: APIRequestContext.head.form = %%-go-fetch-option-form-%%
+* since: v1.26
+
 ### option: APIRequestContext.head.multipart = %%-js-python-fetch-option-multipart-%%
 * since: v1.26
 
 ### option: APIRequestContext.head.multipart = %%-csharp-fetch-option-multipart-%%
 * since: v1.26
 
+### option: APIRequestContext.head.multipart = %%-go-fetch-option-multipart-%%
+* since: v1.26
+
 ### option: APIRequestContext.head.timeout = %%-js-python-csharp-fetch-option-timeout-%%
 * since: v1.16
 
@@ -505,18 +541,27 @@ context cookies from the response. The method will automatically follow redirect
 ### option: APIRequestContext.patch.data = %%-js-python-csharp-fetch-option-data-%%
 * since: v1.16
 
+### option: APIRequestContext.patch.data = %%-go-fetch-option-data-%%
+* since: v1.16
+
 ### option: APIRequestContext.patch.form = %%-js-python-fetch-option-form-%%
 * since: v1.16
 
 ### option: APIRequestContext.patch.form = %%-csharp-fetch-option-form-%%
 * since: v1.16
 
+### option: APIRequestContext.patch.form = %%-go-fetch-option-form-%%
+* since: v1.16
+
 ### option: APIRequestContext.patch.multipart = %%-js-python-fetch-option-multipart-%%
 * since: v1.16
 
 ### option: APIRequestContext.patch.multipart = %%-csharp-fetch-option-multipart-%%
 * since: v1.16
 
+### option: APIRequestContext.patch.multipart = %%-go-fetch-option-multipart-%%
+* since: v1.16
+
 ### option: APIRequestContext.patch.timeout = %%-js-python-csharp-fetch-option-timeout-%%
 * since: v1.16
 
@@ -685,18 +730,27 @@ await request.PostAsync("https://example.com/api/uploadScript", new() { Multipar
 ### option: APIRequestContext.post.data = %%-js-python-csharp-fetch-option-data-%%
 * since: v1.16
 
+### option: APIRequestContext.post.data = %%-go-fetch-option-data-%%
+* since: v1.16
+
 ### option: APIRequestContext.post.form = %%-js-python-fetch-option-form-%%
 * since: v1.16
 
 ### option: APIRequestContext.post.form = %%-csharp-fetch-option-form-%%
 * since: v1.16
 
+### option: APIRequestContext.post.form = %%-go-fetch-option-form-%%
+* since: v1.16
+
 ### option: APIRequestContext.post.multipart = %%-js-python-fetch-option-multipart-%%
 * since: v1.16
 
 ### option: APIRequestContext.post.multipart = %%-csharp-fetch-option-multipart-%%
 * since: v1.16
 
+### option: APIRequestContext.post.multipart = %%-go-fetch-option-multipart-%%
+* since: v1.16
+
 ### option: APIRequestContext.post.timeout = %%-js-python-csharp-fetch-option-timeout-%%
 * since: v1.16
 
@@ -735,18 +789,27 @@ context cookies from the response. The method will automatically follow redirect
 ### option: APIRequestContext.put.data = %%-js-python-csharp-fetch-option-data-%%
 * since: v1.16
 
+### option: APIRequestContext.put.data = %%-go-fetch-option-data-%%
+* since: v1.16
+
 ### option: APIRequestContext.put.form = %%-js-python-fetch-option-form-%%
 * since: v1.16
 
 ### option: APIRequestContext.put.form = %%-csharp-fetch-option-form-%%
 * since: v1.16
 
+### option: APIRequestContext.put.form = %%-go-fetch-option-form-%%
+* since: v1.16
+
 ### option: APIRequestContext.put.multipart = %%-js-python-fetch-option-multipart-%%
 * since: v1.16
 
 ### option: APIRequestContext.put.multipart = %%-csharp-fetch-option-multipart-%%
 * since: v1.16
 
+### option: APIRequestContext.put.multipart = %%-go-fetch-option-multipart-%%
+* since: v1.16
+
 ### option: APIRequestContext.put.timeout = %%-js-python-csharp-fetch-option-timeout-%%
 * since: v1.16
 
diff --git a/docs/src/api/class-apiresponse.md b/docs/src/api/class-apiresponse.md
index 1297d2d4f..6ecc65ae7 100644
--- a/docs/src/api/class-apiresponse.md
+++ b/docs/src/api/class-apiresponse.md
@@ -65,7 +65,7 @@ Headers with multiple entries, such as `Set-Cookie`, appear in the array multipl
 
 ## async method: APIResponse.json
 * since: v1.16
-* langs: js, python
+* langs: js, python, go
 - returns: <[Serializable]>
 
 Returns the JSON representation of response body.
diff --git a/docs/src/api/class-browsercontext.md b/docs/src/api/class-browsercontext.md
index fe3edc74b..2e961136c 100644
--- a/docs/src/api/class-browsercontext.md
+++ b/docs/src/api/class-browsercontext.md
@@ -226,6 +226,7 @@ await context.AddCookiesAsync(new[] { cookie1, cookie2 });
 
 ### param: BrowserContext.addCookies.cookies
 * since: v1.8
+* langs: go
 - `cookies` <[Array]<[Object]>>
   - `name` <[string]>
   - `value` <[string]>
@@ -305,6 +306,20 @@ Script to be evaluated in all pages in the browser context.
 
 Script to be evaluated in all pages in the browser context.
 
+### param: BrowserContext.addInitScript.script
+* since: v1.8
+* langs: go
+- `script` <[string]>
+
+Optional Script source to be evaluated in all pages in the browser context.
+
+### param: BrowserContext.addInitScript.path
+* since: v1.8
+* langs: go
+- `path` <[string]>
+
+Optional Script path to be evaluated in all pages in the browser context.
+
 ### param: BrowserContext.addInitScript.arg
 * since: v1.8
 * langs: js
@@ -1066,7 +1081,7 @@ handler function to route the request.
 
 ### param: BrowserContext.route.handler
 * since: v1.8
-* langs: csharp, java
+* langs: csharp, java,go
 - `handler` <[function]\([Route]\)>
 
 handler function to route the request.
@@ -1291,6 +1306,13 @@ A glob pattern, regex pattern or predicate receiving [URL] used to register a ro
 
 Optional handler function used to register a routing with [`method: BrowserContext.route`].
 
+### param: BrowserContext.unroute.handler
+* since: v1.8
+* langs: go
+- `handler` <[function]\([Route]\)>
+
+Optional handler function used to register a routing with [`method: BrowserContext.route`].
+
 ### param: BrowserContext.unroute.handler
 * since: v1.8
 * langs: csharp, java
@@ -1300,7 +1322,8 @@ Optional handler function used to register a routing with [`method: BrowserConte
 
 ## async method: BrowserContext.waitForEvent
 * since: v1.8
-* langs: js, python
+* langs: js, python, go
+  - alias-go: ExpectEvent
   - alias-python: expect_event
 - returns: <[any]>
 
@@ -1377,7 +1400,8 @@ Receives the [Page] object and resolves to truthy value when the waiting should
 
 ## async method: BrowserContext.waitForEvent2
 * since: v1.8
-* langs: python
+* langs: python, go
+  - alias-go: WaitForEvent
   - alias-python: wait_for_event
 - returns: <[any]>
 
diff --git a/docs/src/api/class-frame.md b/docs/src/api/class-frame.md
index 49b77defd..6ba16526f 100644
--- a/docs/src/api/class-frame.md
+++ b/docs/src/api/class-frame.md
@@ -1858,7 +1858,7 @@ await page.MainFrame.WaitForFunctionAsync("selector => !!document.querySelector(
 
 Optional argument to pass to [`param: expression`].
 
-### option: Frame.waitForFunction.polling = %%-js-python-wait-for-function-polling-%%
+### option: Frame.waitForFunction.polling = %%-js-python-go-wait-for-function-polling-%%
 * since: v1.8
 
 ### option: Frame.waitForFunction.polling = %%-csharp-java-wait-for-function-polling-%%
@@ -1903,6 +1903,11 @@ await frame.WaitForLoadStateAsync(); // Defaults to LoadState.Load
 ```
 
 ### param: Frame.waitForLoadState.state = %%-wait-for-load-state-state-%%
+* langs: js, python, csharp, java
+* since: v1.8
+
+### option: Frame.waitForLoadState.state = %%-wait-for-load-state-state-%%
+* langs: go
 * since: v1.8
 
 ### option: Frame.waitForLoadState.timeout = %%-navigation-timeout-%%
diff --git a/docs/src/api/class-page.md b/docs/src/api/class-page.md
index ef2baf1ab..098414d93 100644
--- a/docs/src/api/class-page.md
+++ b/docs/src/api/class-page.md
@@ -631,6 +631,20 @@ Script to be evaluated in all pages in the browser context.
 
 Optional argument to pass to [`param: script`] (only supported when passing a function).
 
+### param: Page.addInitScript.script
+* since: v1.8
+* langs: go
+- `script` <[string]>
+
+Optional Script source to be evaluated in all pages in the browser context.
+
+### param: Page.addInitScript.path
+* since: v1.8
+* langs: go
+- `path` <[string]>
+
+Optional Script path to be evaluated in all pages in the browser context.
+
 ## async method: Page.addScriptTag
 * since: v1.8
 - returns: <[ElementHandle]>
@@ -1223,11 +1237,11 @@ Passing `null` disables CSS media emulation.
 
 ### option: Page.emulateMedia.media
 * since: v1.9
-* langs: csharp, python
-- `media` <[Media]<"screen"|"print"|"null">>
+* langs: csharp, python, go
+- `media` <[Media]<"screen"|"print"|"no-override">>
 
-Changes the CSS media type of the page. The only allowed values are `'Screen'`, `'Print'` and `'Null'`.
-Passing `'Null'` disables CSS media emulation.
+Changes the CSS media type of the page. The only allowed values are `'screen'`, `'print'` and `'no-override'`.
+Passing `'no-override'` disables CSS media emulation.
 
 ### option: Page.emulateMedia.colorScheme
 * since: v1.9
@@ -1239,11 +1253,11 @@ Emulates `'prefers-colors-scheme'` media feature, supported values are `'light'`
 
 ### option: Page.emulateMedia.colorScheme
 * since: v1.9
-* langs: csharp, python
-- `colorScheme` <[ColorScheme]<"light"|"dark"|"no-preference"|"null">>
+* langs: csharp, python, go
+- `colorScheme` <[ColorScheme]<"light"|"dark"|"no-preference"|"no-override">>
 
 Emulates `'prefers-colors-scheme'` media feature, supported values are `'light'`, `'dark'`, `'no-preference'`. Passing
-`'Null'` disables color scheme emulation.
+`'no-override'` disables color scheme emulation.
 
 ### option: Page.emulateMedia.reducedMotion
 * since: v1.12
@@ -1254,10 +1268,10 @@ Emulates `'prefers-reduced-motion'` media feature, supported values are `'reduce
 
 ### option: Page.emulateMedia.reducedMotion
 * since: v1.12
-* langs: csharp, python
-- `reducedMotion` <[ReducedMotion]<"reduce"|"no-preference"|"null">>
+* langs: csharp, python, go
+- `reducedMotion` <[ReducedMotion]<"reduce"|"no-preference"|"no-override">>
 
-Emulates `'prefers-reduced-motion'` media feature, supported values are `'reduce'`, `'no-preference'`. Passing `null` disables reduced motion emulation.
+Emulates `'prefers-reduced-motion'` media feature, supported values are `'reduce'`, `'no-preference'`. Passing `no-override` disables reduced motion emulation.
 
 ### option: Page.emulateMedia.forcedColors
 * since: v1.15
@@ -1268,8 +1282,8 @@ Emulates `'forced-colors'` media feature, supported values are `'active'` and `'
 
 ### option: Page.emulateMedia.forcedColors
 * since: v1.15
-* langs: csharp, python
-- `forcedColors` <[ForcedColors]<"active"|"none"|"null">>
+* langs: csharp, python, go
+- `forcedColors` <[ForcedColors]<"active"|"none"|"no-override">>
 
 ## async method: Page.evalOnSelector
 * since: v1.9
@@ -2770,7 +2784,7 @@ Paper width, accepts values labeled with units.
 
 ### option: Page.pdf.width
 * since: v1.8
-* langs: csharp, java
+* langs: csharp, java, go
 - `width` <[string]>
 
 Paper width, accepts values labeled with units.
@@ -2784,7 +2798,7 @@ Paper height, accepts values labeled with units.
 
 ### option: Page.pdf.height
 * since: v1.8
-* langs: csharp, java
+* langs: csharp, java, go
 - `height` <[string]>
 
 Paper height, accepts values labeled with units.
@@ -2802,7 +2816,7 @@ Paper margins, defaults to none.
 
 ### option: Page.pdf.margin
 * since: v1.8
-* langs: csharp, java
+* langs: csharp, java, go
 - `margin` <[Object]>
   - `top` ?<[string]> Top margin, accepts values labeled with units. Defaults to `0`.
   - `right` ?<[string]> Right margin, accepts values labeled with units. Defaults to `0`.
@@ -3142,6 +3156,13 @@ it gets merged via the [`new URL()`](https://developer.mozilla.org/en-US/docs/We
 
 handler function to route the request.
 
+### param: Page.route.handler
+* since: v1.8
+* langs: go
+- `handler` <[function]\([Route]\)>
+
+handler function to route the request.
+
 ### param: Page.route.handler
 * since: v1.8
 * langs: csharp, java
@@ -3672,6 +3693,13 @@ A glob pattern, regex pattern or predicate receiving [URL] to match while routin
 
 Optional handler function to route the request.
 
+### param: Page.unroute.handler
+* since: v1.8
+* langs: go
+- `handler` ?<[function]\([Route]\)>
+
+Optional handler function to route the request.
+
 ### param: Page.unroute.handler
 * since: v1.8
 * langs: csharp, java
@@ -3707,7 +3735,8 @@ Performs action and waits for the Page to close.
 
 ## async method: Page.waitForConsoleMessage
 * since: v1.9
-* langs: java, python, csharp
+* langs: java, python, csharp, go
+  - alias-go: ExpectConsoleMessage
   - alias-python: expect_console_message
   - alias-csharp: RunAndWaitForConsoleMessage
 - returns: <[ConsoleMessage]>
@@ -3727,7 +3756,8 @@ Receives the [ConsoleMessage] object and resolves to truthy value when the waiti
 
 ## async method: Page.waitForDownload
 * since: v1.9
-* langs: java, python, csharp
+* langs: java, python, csharp, go
+  - alias-go: ExpectDownload
   - alias-python: expect_download
   - alias-csharp: RunAndWaitForDownload
 - returns: <[Download]>
@@ -3747,7 +3777,8 @@ Receives the [Download] object and resolves to truthy value when the waiting sho
 
 ## async method: Page.waitForEvent
 * since: v1.8
-* langs: js, python
+* langs: js, python, go
+  - alias-go: ExpectEvent
   - alias-python: expect_event
 - returns: <[any]>
 
@@ -3790,7 +3821,8 @@ Either a predicate that receives an event or an options object. Optional.
 
 ## async method: Page.waitForFileChooser
 * since: v1.9
-* langs: java, python, csharp
+* langs: java, python, csharp, go
+  - alias-go: ExpectFileChooser
   - alias-python: expect_file_chooser
   - alias-csharp: RunAndWaitForFileChooser
 - returns: <[FileChooser]>
@@ -3934,7 +3966,7 @@ await page.WaitForFunctionAsync("selector => !!document.querySelector(selector)"
 
 Optional argument to pass to [`param: expression`].
 
-### option: Page.waitForFunction.polling = %%-js-python-wait-for-function-polling-%%
+### option: Page.waitForFunction.polling = %%-js-python-go-wait-for-function-polling-%%
 * since: v1.8
 
 ### option: Page.waitForFunction.polling = %%-csharp-java-wait-for-function-polling-%%
@@ -4024,6 +4056,11 @@ Console.WriteLine(await popup.TitleAsync()); // popup is ready to use.
 ```
 
 ### param: Page.waitForLoadState.state = %%-wait-for-load-state-state-%%
+* langs: js, python, csharp, java
+* since: v1.8
+
+### option: Page.waitForLoadState.state = %%-wait-for-load-state-state-%%
+* langs: go
 * since: v1.8
 
 ### option: Page.waitForLoadState.timeout = %%-navigation-timeout-%%
@@ -4102,7 +4139,8 @@ a navigation.
 
 ## async method: Page.waitForPopup
 * since: v1.9
-* langs: java, python, csharp
+* langs: java, python, csharp, go
+  - alias-go: ExpectPopup
   - alias-python: expect_popup
   - alias-csharp: RunAndWaitForPopup
 - returns: <[Page]>
@@ -4556,7 +4594,8 @@ await page.WaitForURLAsync("**/target.html");
 
 ## async method: Page.waitForWebSocket
 * since: v1.9
-* langs: java, python, csharp
+* langs: java, python, csharp, go
+  - alias-go: ExpectWebSocket
   - alias-python: expect_websocket
   - alias-csharp: RunAndWaitForWebSocket
 - returns: <[WebSocket]>
@@ -4576,7 +4615,8 @@ Receives the [WebSocket] object and resolves to truthy value when the waiting sh
 
 ## async method: Page.waitForWorker
 * since: v1.9
-* langs: java, python, csharp
+* langs: java, python, csharp, go
+  - alias-go: ExpectWorker
   - alias-python: expect_worker
   - alias-csharp: RunAndWaitForWorker
 - returns: <[Worker]>
@@ -4607,7 +4647,8 @@ This does not contain ServiceWorkers
 
 ## async method: Page.waitForEvent2
 * since: v1.8
-* langs: python
+* langs: python, go
+  - alias-go: WaitForEvent
   - alias-python: wait_for_event
 - returns: <[any]>
 
diff --git a/docs/src/api/class-route.md b/docs/src/api/class-route.md
index 9999aac53..430d7637b 100644
--- a/docs/src/api/class-route.md
+++ b/docs/src/api/class-route.md
@@ -121,7 +121,7 @@ If set changes the post data of request.
 
 ### option: Route.continue.postData
 * since: v1.8
-* langs: java
+* langs: java, go
 - `postData` <[string]|[Buffer]>
 
 If set changes the post data of request.
@@ -404,7 +404,7 @@ If set changes the post data of request.
 
 ### option: Route.fallback.postData
 * since: v1.23
-* langs: java
+* langs: java, go
 - `postData` <[string]|[Buffer]>
 
 If set changes the post data of request.
@@ -504,7 +504,7 @@ and `content-type` header will be set to `application/json` if not explicitly se
 set to `application/octet-stream` if not explicitly set.
 
 ### option: Route.fetch.postData
-* langs: java
+* langs: java, go
 * since: v1.29
 - `postData` <[string]|[Buffer]>
 
@@ -617,7 +617,7 @@ If set, equals to setting `Content-Type` response header.
 
 ### option: Route.fulfill.body
 * since: v1.8
-* langs: js, python
+* langs: js, python, go
 - `body` <[string]|[Buffer]>
 
 Response body.
@@ -652,12 +652,14 @@ is resolved relative to the current working directory.
 
 ### option: Route.fulfill.response
 * since: v1.15
+* langs: js, python, java, csharp
 - `response` <[APIResponse]>
 
 [APIResponse] to fulfill route's request with. Individual fields of the response (such as headers) can be overridden using fulfill options.
 
 ## method: Route.request
 * since: v1.8
+* langs: js, python, csharp, java
 - returns: <[Request]>
 
 A request to be routed.
diff --git a/docs/src/api/params.md b/docs/src/api/params.md
index a58da7d77..83ffb2855 100644
--- a/docs/src/api/params.md
+++ b/docs/src/api/params.md
@@ -145,8 +145,8 @@ Defaults to `'visible'`. Can be either:
 * `'hidden'` - wait for element to be either detached from DOM, or have an empty bounding box or `visibility:hidden`.
   This is opposite to the `'visible'` option.
 
-## js-python-wait-for-function-polling
-* langs: js, python
+## js-python-go-wait-for-function-polling
+* langs: js, python, go
 - `polling` <[float]|"raf">
 
 If [`option: polling`] is `'raf'`, then [`param: expression`] is constantly executed in `requestAnimationFrame`
@@ -167,14 +167,14 @@ If `true`, Playwright does not pass its own configurations args and only uses th
 array is given, then filters out the given default arguments. Dangerous option; use with care. Defaults to `false`.
 
 ## csharp-java-browser-option-ignoredefaultargs
-* langs: csharp, java
+* langs: csharp, java, go
 - `ignoreDefaultArgs` <[Array]<[string]>>
 
 If `true`, Playwright does not pass its own configurations args and only uses the ones from [`option: args`].
 Dangerous option; use with care.
 
 ## csharp-java-browser-option-ignorealldefaultargs
-* langs: csharp, java
+* langs: csharp, java, go
 - `ignoreAllDefaultArgs` <[boolean]>
 
 If `true`, Playwright does not pass its own configurations args and only uses the ones from [`option: args`].
@@ -193,7 +193,7 @@ Dangerous option; use with care. Defaults to `false`.
 Network proxy settings.
 
 ## csharp-java-browser-option-env
-* langs: csharp, java
+* langs: csharp, java, go
 - `env` <[Object]<[string], [string]>>
 
 Specify environment variables that will be visible to the browser. Defaults to `process.env`.
@@ -205,7 +205,7 @@ Specify environment variables that will be visible to the browser. Defaults to `
 Specify environment variables that will be visible to the browser. Defaults to `process.env`.
 
 ## js-python-context-option-storage-state
-* langs: js, python
+* langs: js, python, go
 - `storageState` <[path]|[Object]>
   - `cookies` <[Array]<[Object]>> cookies to set for context
     - `name` <[string]>
@@ -233,7 +233,7 @@ Populates context with given storage state. This option can be used to initializ
 obtained via [`method: BrowserContext.storageState`].
 
 ## csharp-java-context-option-storage-state-path
-* langs: csharp, java
+* langs: csharp, java, go
 - `storageStatePath` <[path]>
 
 Populates context with given storage state. This option can be used to initialize context with logged-in information
@@ -310,7 +310,7 @@ Target URL.
 Query parameters to be sent with the URL.
 
 ## csharp-fetch-option-params
-* langs: csharp
+* langs: csharp, go
 - `params` <[Object]<[string], [Serializable]>>
 
 Query parameters to be sent with the URL.
@@ -322,19 +322,19 @@ Query parameters to be sent with the URL.
 Optional request parameters.
 
 ## js-python-csharp-fetch-option-headers
-* langs: js, python, csharp
+* langs: js, python, csharp, go
 - `headers` <[Object]<[string], [string]>>
 
 Allows to set HTTP headers.
 
 ## js-python-csharp-fetch-option-timeout
-* langs: js, python, csharp
+* langs: js, python, csharp, go
 - `timeout` <[float]>
 
 Request timeout in milliseconds. Defaults to `30000` (30 seconds). Pass `0` to disable timeout.
 
 ## js-python-csharp-fetch-option-failonstatuscode
-* langs: js, python, csharp
+* langs: js, python, csharp, go
 - `failOnStatusCode` <[boolean]>
 
 Whether to throw on response codes other than 2xx and 3xx. By default response object is returned
@@ -358,6 +358,14 @@ unless explicitly provided.
 
 An instance of [FormData] can be created via [`method: APIRequestContext.createFormData`].
 
+## go-fetch-option-form
+* langs: go
+- `form` <[any]>
+
+Provides an object that will be serialized as html form using `application/x-www-form-urlencoded` encoding and sent as
+this request body. If this parameter is specified `content-type` header will be set to `application/x-www-form-urlencoded`
+unless explicitly provided.
+
 ## js-python-fetch-option-multipart
 * langs: js, python
 - `multipart` <[Object]<[string], [string]|[float]|[boolean]|[ReadStream]|[Object]>>
@@ -381,6 +389,15 @@ or as file-like object containing file name, mime-type and its content.
 
 An instance of [FormData] can be created via [`method: APIRequestContext.createFormData`].
 
+## go-fetch-option-multipart
+* langs: go
+- `multipart` <[any]>
+
+Provides an object that will be serialized as html form using `multipart/form-data` encoding and sent as
+this request body. If this parameter is specified `content-type` header will be set to `multipart/form-data`
+unless explicitly provided. File values can be passed either as [`fs.ReadStream`](https://nodejs.org/api/fs.html#fs_class_fs_readstream)
+or as file-like object containing file name, mime-type and its content.
+
 ## js-python-csharp-fetch-option-data
 * langs: js, python, csharp
 - `data` <[string]|[Buffer]|[Serializable]>
@@ -389,14 +406,22 @@ Allows to set post data of the request. If the data parameter is an object, it w
 and `content-type` header will be set to `application/json` if not explicitly set. Otherwise the `content-type` header will be
 set to `application/octet-stream` if not explicitly set.
 
+## go-fetch-option-data
+* langs: go
+- `data` <[any]>
+
+Allows to set post data of the request. If the data parameter is an object, it will be serialized to json string
+and `content-type` header will be set to `application/json` if not explicitly set. Otherwise the `content-type` header will be
+set to `application/octet-stream` if not explicitly set.
+
 ## js-python-csharp-fetch-option-ignorehttpserrors
-* langs: js, python, csharp
+* langs: js, python, csharp, go
 - `ignoreHTTPSErrors` <[boolean]>
 
 Whether to ignore HTTPS errors when sending network requests. Defaults to `false`.
 
 ## js-python-csharp-fetch-option-maxredirects
-* langs: js, python, csharp
+* langs: js, python, csharp, go
 - `maxRedirects` <[int]>
 
 Maximum number of request redirects that will be followed automatically. An error will be thrown if the number is exceeded.
@@ -439,7 +464,7 @@ Function to be evaluated in the worker context.
 Function to be evaluated in the worker context.
 
 ## python-context-option-viewport
-* langs: python
+* langs: python, go
 - `viewport` <[null]|[Object]>
   - `width` <[int]> page width in pixels.
   - `height` <[int]> page height in pixels.
@@ -447,7 +472,7 @@ Function to be evaluated in the worker context.
 Sets a consistent viewport for each page. Defaults to an 1280x720 viewport. `no_viewport` disables the fixed viewport.
 
 ## python-context-option-no-viewport
-* langs: python
+* langs: python, go
 - `noViewport` <[boolean]>
 
 Does not enforce fixed viewport, allows resizing window in the headed mode.
@@ -527,11 +552,11 @@ Emulates `'prefers-colors-scheme'` media feature, supported values are `'light'`
 [`method: Page.emulateMedia`] for more details. Passing `null` resets emulation to system defaults. Defaults to `'light'`.
 
 ## context-option-colorscheme-csharp-python
-* langs: csharp, python
-- `colorScheme` <[ColorScheme]<"light"|"dark"|"no-preference"|"null">>
+* langs: csharp, python, go
+- `colorScheme` <[ColorScheme]<"light"|"dark"|"no-preference"|"no-override">>
 
 Emulates `'prefers-colors-scheme'` media feature, supported values are `'light'`, `'dark'`, `'no-preference'`. See
-[`method: Page.emulateMedia`] for more details. Passing `'null'` resets emulation to system defaults. Defaults to `'light'`.
+[`method: Page.emulateMedia`] for more details. Passing `'no-override'` resets emulation to system defaults. Defaults to `'light'`.
 
 ## context-option-reducedMotion
 * langs: js, java
@@ -540,10 +565,10 @@ Emulates `'prefers-colors-scheme'` media feature, supported values are `'light'`
 Emulates `'prefers-reduced-motion'` media feature, supported values are `'reduce'`, `'no-preference'`. See [`method: Page.emulateMedia`] for more details. Passing `null` resets emulation to system defaults. Defaults to `'no-preference'`.
 
 ## context-option-reducedMotion-csharp-python
-* langs: csharp, python
-- `reducedMotion` <[ReducedMotion]<"reduce"|"no-preference"|"null">>
+* langs: csharp, python, go
+- `reducedMotion` <[ReducedMotion]<"reduce"|"no-preference"|"no-override">>
 
-Emulates `'prefers-reduced-motion'` media feature, supported values are `'reduce'`, `'no-preference'`. See [`method: Page.emulateMedia`] for more details. Passing `'null'` resets emulation to system defaults. Defaults to `'no-preference'`.
+Emulates `'prefers-reduced-motion'` media feature, supported values are `'reduce'`, `'no-preference'`. See [`method: Page.emulateMedia`] for more details. Passing `'no-override'` resets emulation to system defaults. Defaults to `'no-preference'`.
 
 ## context-option-forcedColors
 * langs: js, java
@@ -552,10 +577,10 @@ Emulates `'prefers-reduced-motion'` media feature, supported values are `'reduce
 Emulates `'forced-colors'` media feature, supported values are `'active'`, `'none'`. See [`method: Page.emulateMedia`] for more details. Passing `null` resets emulation to system defaults. Defaults to `'none'`.
 
 ## context-option-forcedColors-csharp-python
-* langs: csharp, python
-- `forcedColors` <[ForcedColors]<"active"|"none"|"null">>
+* langs: csharp, python, go
+- `forcedColors` <[ForcedColors]<"active"|"none"|"no-override">>
 
-Emulates `'forced-colors'` media feature, supported values are `'active'`, `'none'`. See [`method: Page.emulateMedia`] for more details. Passing `'null'` resets emulation to system defaults. Defaults to `'none'`.
+Emulates `'forced-colors'` media feature, supported values are `'active'`, `'none'`. See [`method: Page.emulateMedia`] for more details. Passing `'no-override'` resets emulation to system defaults. Defaults to `'none'`.
 
 ## context-option-logger
 * langs: js
@@ -590,7 +615,7 @@ specified, the HAR is not recorded. Make sure to await [`method: BrowserContext.
 saved.
 
 ## context-option-recordhar-path
-* langs: csharp, java, python
+* langs: csharp, java, python, go
   - alias-python: record_har_path
 - `recordHarPath` <[path]>
 
@@ -599,33 +624,33 @@ specified HAR file on the filesystem. If not specified, the HAR is not recorded.
 call [`method: BrowserContext.close`] for the HAR to be saved.
 
 ## context-option-recordhar-omit-content
-* langs: csharp, java, python
+* langs: csharp, java, python, go
   - alias-python: record_har_omit_content
 - `recordHarOmitContent` ?<[boolean]>
 
 Optional setting to control whether to omit request content from the HAR. Defaults to `false`.
 
 ## context-option-recordhar-content
-* langs: csharp, java, python
+* langs: csharp, java, python, go
   - alias-python: record_har_content
 - `recordHarContent` ?<[HarContentPolicy]<"omit"|"embed"|"attach">>
 
 Optional setting to control resource content management. If `omit` is specified, content is not persisted. If `attach` is specified, resources are persisted as separate files and all of these files are archived along with the HAR file. Defaults to `embed`, which stores content inline the HAR file as per HAR specification.
 
 ## context-option-recordhar-mode
-* langs: csharp, java, python
+* langs: csharp, java, python, go
   - alias-python: record_har_mode
 - `recordHarMode` ?<[HarMode]<"full"|"minimal">>
 
 When set to `minimal`, only record information necessary for routing from HAR. This omits sizes, timing, page, cookies, security and other types of HAR information that are not used when replaying from HAR. Defaults to `full`.
 
 ## context-option-recordhar-url-filter
-* langs: csharp, java, python
+* langs: csharp, java, python, go
   - alias-python: record_har_url_filter
 - `recordHarUrlFilter` ?<[string]|[RegExp]>
 
 ## context-option-recordvideo
-* langs: js
+* langs: js, go
 - `recordVideo` <[Object]>
   - `dir` <[path]> Path to the directory to put videos into.
   - `size` ?<[Object]> Optional dimensions of the recorded videos. If not specified the size will be equal to `viewport`
@@ -767,7 +792,7 @@ only the first option matching one of the passed options is selected. Optional.
 Receives the event data and resolves to truthy value when the waiting should resolve.
 
 ## wait-for-event-timeout
-* langs: csharp, java, python
+* langs: csharp, java, python, go
 - `timeout` <[float]>
 
 Maximum time to wait for in milliseconds. Defaults to `30000` (30 seconds). Pass `0` to disable timeout.
@@ -917,7 +942,7 @@ Firefox user preferences. Learn more about the Firefox user preferences at
 [`about:config`](https://support.mozilla.org/en-US/kb/about-config-editor-firefox).
 
 ## csharp-java-browser-option-firefoxuserprefs
-* langs: csharp, java
+* langs: csharp, java, go
 - `firefoxUserPrefs` <[Object]<[string], [any]>>
 
 Firefox user preferences. Learn more about the Firefox user preferences at
@@ -1029,6 +1054,7 @@ saved to the disk.
 Specify screenshot type, defaults to `png`.
 
 ## screenshot-option-mask
+* langs: js, python, csharp
 - `mask` <[Array]<[Locator]>>
 
 Specify locators that should be masked when the screenshot is taken. Masked elements will be overlaid with
diff --git a/utils/doclint/generateGoApi.js b/utils/doclint/generateGoApi.js
new file mode 100644
index 000000000..6b3cfa844
--- /dev/null
+++ b/utils/doclint/generateGoApi.js
@@ -0,0 +1,821 @@
+/**
+ * Copyright (c) Microsoft Corporation.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+// @ts-check
+
+const path = require('path');
+const Documentation = require('./documentation');
+const XmlDoc = require('./dotnetXmlDocumentation')
+const PROJECT_DIR = path.join(__dirname, '..', '..');
+const fs = require('fs');
+const { parseApi } = require('./api_parser');
+const { Type } = require('./documentation');
+const { EOL } = require('os');
+
+
+const maxDocumentationColumnWidth = 80;
+
+/** @type {Map<string, Documentation.Type>} */
+const additionalTypes = new Map(); // this will hold types that we discover, because of .NET specifics, like results
+/** @type {Map<string, string>} */
+const documentedResults = new Map(); // will hold documentation for new types
+/** @type {Map<string, string[]>} */
+const enumTypes = new Map();
+
+let documentation;
+/** @type {Map<string, string>} */
+let classNameMap;
+/** @type {Map<string, string>} */
+let shortNameMap = new Map();
+
+{
+  const typesDir = process.argv[2] || path.join(__dirname, 'generate_types', 'go');
+  if (!fs.existsSync(typesDir))
+    fs.mkdirSync(typesDir, { recursive: true });
+
+  const structsFile = path.join(typesDir, "generated-structs.go");
+  const enumsFile = path.join(typesDir, "generated-enums.go");
+
+  for (const file of [structsFile, enumsFile])
+    fs.writeFileSync(file, "package playwright\n")
+
+  documentation = parseApi(path.join(PROJECT_DIR, 'docs', 'src', 'api'));
+  documentation.filterForLanguage('go');
+  documentation.setLinkRenderer(item => {
+    if (item.clazz)
+      return translateMemberName("interface", item.clazz.name, null);
+    else if (item.option || item.param)
+      return `\`${item.option || item.param}\``
+    else if (item.member)
+      return `${translateMemberName("interface", item.member.clazz.name, null)}.${translateMemberName(item.member.kind, item.member.name, item.member)}()`;
+  });
+  // we have some "predefined" types, like the mixed state enum, that we can map in advance
+  enumTypes.set("MixedState", ["On", "Off", "Mixed"]);
+
+  // map the name to a C# friendly one (we prepend an I to denote an interface)
+  classNameMap = new Map(documentation.classesArray.map(x => [x.name, translateMemberName('interface', x.name, null)]));
+
+  // map some types that we know of
+  classNameMap.set('Error', 'Exception');
+  classNameMap.set('TimeoutError', 'TimeoutException');
+  classNameMap.set('EvaluationArgument', 'interface{}');
+  classNameMap.set('boolean', '*bool');
+  classNameMap.set('Serializable', 'T');
+  classNameMap.set('any', 'interface{}');
+  classNameMap.set('Buffer', '[]byte'); // TODO(mxschmitt): use bytes.Buffer
+  classNameMap.set('path', '*string');
+  classNameMap.set('URL', 'string');
+  classNameMap.set('RegExp', 'Regex');
+
+  // map some types that keep the name short
+  shortNameMap.set('HttpCredentials', 'HttpCredentials')
+  shortNameMap.set('Proxy', 'Proxy')
+  shortNameMap.set('APIRequestContextStorageState', 'StorageState')
+  shortNameMap.set('BrowserContextStorageState', 'StorageState')
+  shortNameMap.set('APIRequestNewContextOptionsStorageState', 'StorageState')
+  shortNameMap.set('APIRequestNewContextStorageState', 'StorageState')
+  shortNameMap.set('BrowserNewContextOptionsStorageState', 'OptionalStorageState')
+  shortNameMap.set('BrowserNewPageOptionsStorageState', 'OptionalStorageState')
+  shortNameMap.set('OptionalStorageStateOrigins', 'OriginsState')
+  shortNameMap.set('RecordVideo', 'RecordVideo')
+  shortNameMap.set('Screen', 'ScreenSize')
+  shortNameMap.set('Viewport', 'ViewportSize')
+  shortNameMap.set('PageViewportSizeResult', 'ViewportSize')
+  shortNameMap.set('BrowserNewContextOptionsGeolocation', 'Geolocation')
+  shortNameMap.set('BrowserNewPageOptionsGeolocation', 'Geolocation')
+  shortNameMap.set('BrowserTypeLaunchPersistentContextOptionsGeolocation', 'Geolocation')
+  shortNameMap.set('OptionalStorageStateCookies', 'OptionalCookie')
+  shortNameMap.set('BrowserContextAddCookiesOptionsCookies', 'OptionalCookie')
+  shortNameMap.set('BrowserContextCookies', 'Cookie')
+  shortNameMap.set('Position', 'Position')
+  shortNameMap.set('SourcePosition', 'Position')
+  shortNameMap.set('TargetPosition', 'Position')
+  shortNameMap.set('Margin', 'Margin')
+  shortNameMap.set('HeadersArray', 'NameValue')
+  shortNameMap.set('PageScreenshotOptionsClip', 'Rect')
+
+  // this are types that we don't explicility render even if we get the specs
+  const ignoredTypes = [
+    'TimeoutException',
+    'APIRequestStorageState',
+    'APIRequestContextStorageStateResult',
+    'APIResponseHeadersArrayResult',
+    'BrowserGeolocation',
+    'BrowserStorageState',
+    'BrowserContextGeolocation',
+    'BrowserContextStorageStateResult',
+    'BrowserContextCookiesResult',
+    'BrowserTypeGeolocation',
+    'Cookie',
+    'ElementHandleBoundingBoxResult',
+    'Geolocation',
+    'HttpCredentials',
+    'LocatorBoundingBoxResult',
+    'NameValue',
+    'OriginsState',
+    'PageClip',
+    'PageViewportSizeResult',
+    'Rect',
+    'RequestHeadersArrayResult',
+    'ResponseHeadersArrayResult',
+    'StorageState',
+    'ViewportSize'
+  ];
+
+  /**
+   * @param {string} file
+   * @param {string[]} data
+   */
+  let appendFile = (file, data) => {
+    let content = data.join(`${EOL}\t`);
+    fs.appendFileSync(file, content);
+  }
+
+  for (const element of documentation.classesArray) {
+    const name = classNameMap.get(element.name);
+    if (ignoredTypes.includes(name))
+      continue;
+
+    const out = [];
+    console.log(`Generating ${name}`);
+
+    if (element.spec)
+      out.push(...XmlDoc.renderXmlDoc(element.spec, maxDocumentationColumnWidth));
+    else {
+      let ownDocumentation = documentedResults.get(name);
+      if (ownDocumentation) {
+        out.push(`// ${ownDocumentation}`);
+      }
+    }
+
+    if (element.extends === 'IEventEmitter')
+      element.extends = null;
+
+    out.push(`type ${name} interface {`);
+    if (element.extends)
+      out.push(element.extends)
+
+    for (const member of element.membersArray) {
+      renderMember(member, element, out);
+    }
+
+    // we want to separate the items with a space and this is nicer, than holding
+    // an index in each iterator down the line
+    const lastLine = out.pop();
+    if (lastLine !== '')
+      out.push(lastLine);
+
+    out.push('}');
+  }
+
+  additionalTypes.forEach((type, name) => {
+    if (name.startsWith("Android") || name.startsWith("Electron") || ignoredTypes.includes(name) || !type.properties?.length)
+      return
+    const out = []
+    let ownDocumentation = documentedResults.get(name);
+    if (ownDocumentation)
+      out.push(`// ${ownDocumentation}`)
+    out.push(`type ${name} struct {`)
+    // TODO: consider how this could be merged with the `translateType` check
+    if (type.union
+      && type.union[0].name === 'null'
+      && type.union.length == 2) {
+      type = type.union[1];
+    }
+
+    if (type.name === 'Array') {
+      throw new Error('Array at this stage is unexpected.');
+    } else if (type.properties) {
+      for (const member of type.properties) {
+        let fakeType = new Type(name, null);
+        renderMember(member, fakeType, out);
+      }
+    } else if (type.union) {
+      console.log("enum", type)
+    } else {
+      console.log(type);
+      throw new Error(`Not sure what to do in this case.`);
+    }
+    out.push("}\n")
+    appendFile(structsFile, out);
+  });
+
+  enumTypes.forEach((values, name) => {
+    const out = []
+    const fcall = `get${name}`
+    out.push(`func ${fcall}(in string) *${name} {
+      v := ${name}(in)
+      return &v
+    }
+    `)
+
+    out.push(`type ${name} string`)
+    out.push(" var (")
+    values.forEach((v, i) => {
+      // strip out the quotes
+      v = v.replace(/[\"]/g, ``)
+      let escapedEnumValue = v.replace(/[-]/g, ' ')
+        .split(' ')
+        .map(word => word[0].toUpperCase() + word.substring(1)).join('');
+
+      if (i === 0)
+        out.push(`${name}${escapedEnumValue} *${name} = ${fcall}("${v}")`)
+      else
+        out.push(`${name}${escapedEnumValue} = ${fcall}("${v}")`)
+    });
+    out.push(")\n")
+
+    appendFile(enumsFile, out);
+  });
+}
+
+/**
+ * @param {string} memberKind
+ * @param {string} name
+ * @param {Documentation.Member} member
+ */
+function translateMemberName(memberKind, name, member = null) {
+  if (!name) return name;
+
+  // we strip it for special chars, like @ because we might get called back with it in some special cases
+  // like, when generating classes inside methods for params
+  name = name.replace(/[@-]/g, '');
+
+  if (memberKind === 'argument') {
+    if (['params', 'event'].includes(name)) { // just in case we want to add others
+      return `@${name}`;
+    } else {
+      return name;
+    }
+  }
+
+  // check if there's an alias in the docs, in which case
+  // we return that, otherwise, we apply our dotnet magic to it
+  if (member) {
+    if (member.alias !== name) {
+      return member.alias;
+    }
+  }
+
+  // we sanitize some common abbreviations to ensure consistency
+  name = name.replace(/(HTTP[S]?)/g, (m, g) => {
+    return g[0].toUpperCase() + g.substring(1).toLowerCase();
+  });
+
+  if (name === "url")
+    return "URL"
+
+  let assumedName = name.charAt(0).toUpperCase() + name.substring(1);
+
+  switch (memberKind) {
+    case "interface":
+      // apply name mapping if the map exists
+      let mappedName = classNameMap ? classNameMap.get(assumedName) : null;
+      if (mappedName)
+        return mappedName;
+      return `${assumedName}`;
+    case "method":
+      if (member)
+        return `${assumedName}`;
+      return assumedName;
+    case "event":
+      return `${assumedName}`;
+    case "enum":
+      return `${assumedName}`;
+    default:
+      return `${assumedName}`;
+  }
+}
+
+/**
+ *
+ * @param {Documentation.Member} member
+ * @param {Documentation.Class|Documentation.Type} parent
+ * @param {string[]} out
+ */
+function renderMember(member, parent, out) {
+  let output = line => {
+    if (typeof (line) === 'string')
+      out.push(`\t${line}`);
+    else
+      out.push(...line.map(x => `\t${x}`));
+  }
+
+  let name = translateMemberName(member.kind, member.name, member);
+  if (member.kind === 'method') {
+    renderMethod(member, parent, output, name);
+  } else {
+    let type = translateType(member.type, parent, t => generateNameDefault(member, name, t, parent));
+    if (member.kind === 'event') {
+      if (!member.type)
+        throw new Error(`No Event Type for ${name} in ${parent.name}`);
+      if (member.spec)
+        output(XmlDoc.renderXmlDoc(member.spec, maxDocumentationColumnWidth));
+    } else if (member.kind === 'property') {
+      if (member.spec) {
+        const text = member.spec
+        if (text.length > 0) {
+          text.forEach(line => {
+            let words = line.text.replace(/↵/g, ' ').split(' ');
+            let lines = [];
+            let lineText = "";
+            for (let i = 0; i < words.length; i++) {
+              lineText += ' ' + words[i];
+              if (lineText.length >= maxDocumentationColumnWidth) {
+                lines.push(lineText);
+                lineText = '';
+              }
+            }
+            lines.push(lineText);
+            lines.filter(line => !["", " "].includes(line)).forEach(line => output(`//${line}`));
+          }
+          )
+        }
+      }
+      let propertyOrigin = member.name;
+      if (member.type.expression === '[string]|[float]')
+        propertyOrigin = `${member.name}String`;
+      if (parent && member && member.name === 'children') {  // this is a special hack for Accessibility
+        console.warn(`children property found in ${parent.name}, assuming array.`);
+        type = `[]${parent.name}`;
+      }
+      if (parent.name.endsWith("Result")) {
+        type = type.replace("*", "")
+      }
+      output(`${name} ${type} \`json:"${propertyOrigin}"\``);
+    } else {
+      throw new Error(`Problem rendering a member: ${type} - ${name} (${member.kind})`);
+    }
+  }
+}
+
+/**
+ *
+ * @param {Documentation.Member} member
+ * @param {string} name
+ * @param {Documentation.Type} t
+ * @param {*} parent
+ */
+function generateNameDefault(member, name, t, parent) {
+  if (!t.properties
+    && !t.templates
+    && !t.union
+    && t.expression === '[Object]')
+    return 'interface{}';
+
+  // we'd get this call for enums, primarily
+  let enumName = generateEnumNameIfApplicable(member, name, t, parent);
+  if (!enumName && member) {
+    if (member.kind === 'method' || member.kind === 'property') {
+      // this should be easy to name... let's call it the same as the argument (eternal optimist)
+      let memberName = `${translateMemberName(``, name, null)}`;
+      let probableName = `${parent.name}${memberName}`;
+      let shortName = shortNameMap.get(`${probableName}`) ? shortNameMap.get(`${probableName}`) : shortNameMap.get(`${memberName}`);
+      probableName = shortName ? shortName : probableName
+      let probableType = additionalTypes.get(probableName);
+      if (probableType) {
+        // compare it with what?
+        if (probableType.expression != t.expression) {
+          throw new Error(`Non-matching types with the same name. Panic.`);
+        }
+      } else {
+        additionalTypes.set(probableName, t);
+      }
+
+      return probableName;
+    }
+
+    if (member.kind === 'event') {
+      return `${name}Payload`;
+    }
+  }
+
+  return enumName || t.name;
+}
+
+function generateEnumNameIfApplicable(member, name, type, parent) {
+  if (!type.union)
+    return null;
+
+  const potentialValues = type.union.filter(u => u.name.startsWith('"'));
+  if ((potentialValues.length !== type.union.length)
+    && !(type.union[0].name === 'null' && potentialValues.length === type.union.length - 1))
+    return null; // this isn't an enum, so we don't care, we let the caller generate the name
+
+  if (type && type.name)
+    return type.name;
+
+  // our enum naming policy leaves a few bits to be desired, but it'll do for now
+  // however, with the recent changes, this almost never gets called anymore
+  return translateMemberName('enum', name, type);
+}
+
+/**
+ *
+ * @param {string} v
+ * @returns {string}
+ */
+function makeFirstCharUpperCase(v) {
+  return v[0].toUpperCase() + v.slice(1)
+}
+
+/**
+ * Rendering a method is so _special_, with so many weird edge cases, that it
+ * makes sense to put it separate from the other logic.
+ * @param {Documentation.Member} member
+ * @param {Documentation.Class|Documentation.Type} parent
+ * @param {Function} output
+ */
+function renderMethod(member, parent, output, name) {
+  const typeResolve = (type) => translateType(type, parent, (t) => {
+    let newName = `${parent.name}${translateMemberName(member.kind, member.name, null)}Result`;
+    documentedResults.set(newName, `Result of calling <see cref="${translateMemberName("interface", parent.name)}.${translateMemberName(member.kind, member.name, member)}" />.`);
+    return newName;
+  });
+
+  /** @type {Map<string, string[]>} */
+  const paramDocs = new Map();
+  /**
+   * @param {string} paramName
+   * @param {string[]} docs
+   */
+  const addParamsDoc = (paramName, docs) => {
+    if (paramName.startsWith('@'))
+      paramName = paramName.substring(1);
+    if (paramDocs.get(paramName))
+      throw new Error(`Parameter ${paramName} already exists in the docs.`);
+    paramDocs.set(paramName, docs);
+  };
+
+  /** @type {string} */
+  let type = null;
+  // need to check the original one
+  if (member.type.name === 'Object' || member.type.name === 'Array') {
+    let innerType = member.type;
+    let isArray = false;
+    if (innerType.name === 'Array') {
+      // we want to influence the name, but also change the object type
+      innerType = member.type.templates[0];
+      isArray = true;
+    }
+
+    if (innerType.expression === '[Object]<[string], [string]>') {
+      // do nothing, because this is handled down the road
+    } else if (!isArray && !innerType.properties) {
+      type = `dynamic`;
+    } else {
+      type = classNameMap.get(innerType.name);
+      if (!type) {
+        type = typeResolve(innerType);
+      }
+
+      if (isArray)
+        type = `IReadOnlyCollection<${type}>`;
+    }
+  }
+
+  type = type || typeResolve(member.type);
+
+  const optionsStructName = `${parent.name}${makeFirstCharUpperCase(member.alias)}Options`
+  let optionsStructMembers = member.argsArray.find(a => a.name === "options")?.type.properties || []
+  if (!optionsStructMembers.length)
+    optionsStructMembers = member.argsArray.filter(a => (!a.required || a.langs.only?.includes("go")))
+
+  if (optionsStructMembers.length > 0) {
+    let fakeType = new Type("Object", optionsStructMembers);
+    additionalTypes.set(optionsStructName, fakeType)
+  }
+  // TODO: this is something that will probably go into the docs
+  // translate simple getters into read-only properties, and simple
+  // set-only methods to settable properties
+  if (member.args.size == 0
+    && type !== 'void'
+    && !name.startsWith('Get')) {
+    if (!member.async) {
+      if (member.spec)
+        output(XmlDoc.renderXmlDoc(member.spec, maxDocumentationColumnWidth));
+      output(`${type} ${name} { get; }`);
+      return;
+    }
+    name = `Get${name}`;
+  } else if (member.args.size == 1
+    && type === 'void'
+    && name.startsWith('Set')
+    && !member.async) {
+    name = name.substring(3); // remove the 'Set'
+    if (member.spec)
+      output(XmlDoc.renderXmlDoc(member.spec, maxDocumentationColumnWidth));
+    output(`${translateType(member.argsArray[0].type, parent)} ${name} { set; }`);
+    return;
+  }
+
+  // HACK: special case for generics handling!
+  if (type === 'T') {
+    name = `${name}<T>`;
+  }
+
+  // adjust the return type for async methods
+  // if (member.async) {
+  //   if (type === 'void')
+  //     type = `Task`;
+  //   else
+  //     type = `Task<${type}>`;
+  // }
+
+  // render args
+  let args = [];
+  /**
+   *
+   * @param {string} innerArgType
+   * @param {string} innerArgName
+   * @param {Documentation.Member} argument
+   */
+  const pushArg = (innerArgType, innerArgName, argument) => {
+    let isNullable = ['int', 'bool', 'decimal', 'float'].includes(innerArgType);
+    const requiredPrefix = argument.required ? "" : isNullable ? "?" : "";
+    const requiredSuffix = argument.required ? "" : " = default";
+    args.push(`${innerArgType}${requiredPrefix} ${innerArgName}${requiredSuffix}`);
+  };
+
+  let parseArg = (/** @type {Documentation.Member} */ arg) => {
+    if (arg.name === "options") {
+      arg.type.properties.forEach(prop => {
+        parseArg(prop);
+      });
+      return;
+    }
+
+    if (arg.type.expression === '[string]|[path]') {
+      let argName = translateMemberName('argument', arg.name, null);
+      pushArg("string", argName, arg);
+      pushArg("string", `${argName}Path`, arg);
+      if (arg.spec) {
+        addParamsDoc(argName, XmlDoc.renderTextOnly(arg.spec, maxDocumentationColumnWidth));
+        addParamsDoc(`${argName}Path`, [`Instead of specifying <paramref name="${argName}"/>, gives the file name to load from.`]);
+      }
+      return;
+    } else if (arg.type.expression === '[boolean]|[Array]<[string]>') {
+      // HACK: this hurts my brain too
+      // we split this into two args, one boolean, with the logical name
+      let argName = translateMemberName('argument', arg.name, null);
+      let leftArgType = translateType(arg.type.union[0], parent, (t) => { throw new Error('Not supported'); });
+      let rightArgType = translateType(arg.type.union[1], parent, (t) => { throw new Error('Not supported'); });
+
+      pushArg(leftArgType, argName, arg);
+      pushArg(rightArgType, `${argName}Values`, arg);
+
+      addParamsDoc(argName, XmlDoc.renderTextOnly(arg.spec, maxDocumentationColumnWidth));
+      addParamsDoc(`${argName}Values`, [`The values to take into account when <paramref name="${argName}"/> is <code>true</code>.`]);
+
+      return;
+    }
+
+    const argName = translateMemberName('argument', arg.alias || arg.name, null);
+    const argType = translateType(arg.type, parent, (t) => generateNameDefault(member, argName, t, parent));
+
+    if (argType === null && arg.type.union) {
+      // we might have to split this into multiple arguments
+      let translatedArguments = arg.type.union.map(t => translateType(t, parent, (x) => generateNameDefault(member, argName, x, parent)));
+      if (translatedArguments.includes(null))
+        throw new Error('Unexpected null in translated argument types. Aborting.');
+
+      let argDocumentation = XmlDoc.renderTextOnly(arg.spec, maxDocumentationColumnWidth);
+      for (const newArg of translatedArguments) {
+        const sanitizedArgName = newArg.match(/(?<=^[\s"']*)(\w+)/g, '')?.[0] || newArg;
+        const newArgName = `${argName}${sanitizedArgName[0].toUpperCase() + sanitizedArgName.substring(1)}`;
+        pushArg(newArg, newArgName, arg);
+        addParamsDoc(newArgName, argDocumentation);
+      }
+      return;
+    }
+
+    addParamsDoc(argName, XmlDoc.renderTextOnly(arg.spec, maxDocumentationColumnWidth));
+
+    if (argName === 'timeout' && argType === 'decimal') {
+      args.push(`int timeout = 0`); // a special argument, we ignore our convention
+      return;
+    }
+
+    pushArg(argType, argName, arg);
+  };
+
+  member.args.forEach(parseArg);
+
+  output(XmlDoc.renderXmlDoc(member.spec, maxDocumentationColumnWidth));
+  paramDocs.forEach((val, ind) => {
+    if (val && val.length === 1)
+      output(`/// <param name="${ind}">${val}</param>`);
+    else {
+      output(`/// <param name="${ind}">`);
+      output(val.map(l => `/// ${l}`));
+      output(`/// </param>`);
+    }
+  });
+  output(`${name}(${args.join(', ')}) ${type}`);
+}
+
+/**
+ *
+ *  @callback generateNameCallback
+ *  @param {Documentation.Type} t
+ *  @returns {string}
+ */
+
+/**
+ *  @param {Documentation.Type} type
+ *  @param {Documentation.Class|Documentation.Type} parent
+ *  @param {generateNameCallback} generateNameCallback
+*/
+function translateType(type, parent, generateNameCallback = t => t.name) {
+  if (type.name === "int")
+    return "*int"
+  if (type.name === "string")
+    return "*string"
+  if (type.name === "float")
+    return "*float64"
+  if (type.name === "Serializable")
+    return "interface{}"
+  if (type.name === "Logger")
+    return "interface{}"
+  // a few special cases we can fix automatically
+  if (type.expression === '[null]|[Error]')
+    return 'void';
+  else if (type.expression === '[boolean]|"mixed"')
+    return 'MixedState';
+
+  let isNullableEnum = false;
+  if (type.union) {
+    if (type.union[0].name === 'null') {
+      // for dotnet, this is a nullable type
+      // if the other side is a primitive type
+      if (type.union.length > 2) {
+        if (type.union.filter(x => x.name.startsWith('"')).length == type.union.length - 1)
+          isNullableEnum = true;
+        else
+          return `interface{}`
+        // throw new Error(`Union (${parent.name}) with null is too long.`);
+      } else {
+        const innerTypeName = translateType(type.union[1], parent, generateNameCallback);
+        // if type is primitive, or an enum, then it's nullable
+        if (innerTypeName === 'bool'
+          || innerTypeName === 'int') {
+          return `${innerTypeName}?`;
+        }
+
+        // if it's not a value type, it'll be nullable by default, so we can ignore it
+        return `${innerTypeName}`;
+      }
+    }
+
+    if (type.union.filter(u => u.name.startsWith(`"`)).length == type.union.length
+      || isNullableEnum) {
+      // this is an enum
+      let enumName = generateNameCallback(type);
+      if (!enumName)
+        throw new Error(`This was supposed to be an enum, but it failed generating a name, ${type.name} ${parent ? parent.name : ""}.`);
+
+      // make sure we map the enum, or invalidate the name, in case it doesn't match well
+      const potentialEnum = enumTypes.get(enumName);
+      let enumValues = type.union.filter(x => x.name !== 'null').map(x => x.name);
+      if (potentialEnum) {
+        // compare values
+        if (potentialEnum.join(',') !== enumValues.join(',')) {
+          // for now, we'll merge the two enums, if they have the same name, and we'll go from there
+          potentialEnum.concat(enumValues.filter(x => !potentialEnum.includes(x))); // merge & de-dupe
+          // TODO: think about doing global type annotation, where we can add comments, such as this?
+          enumTypes.set(enumName, potentialEnum);
+        }
+      } else {
+        enumTypes.set(enumName, enumValues);
+      }
+      if (isNullableEnum)
+        return `*${enumName}?`;
+      return `*${enumName}`;
+    }
+
+    if (type.expression === '[string]|[Buffer]')
+      return `interface{}`; // TODO: make sure we implement extension methods for this!
+    else if (type.expression === '[string]|[float]'
+      || type.expression === '[string]|[float]|[boolean]') {
+      console.warn(`${type.name} should be a 'string', but was a ${type.expression}`);
+      return `string`;
+    } else if (type.union.length == 2 && type.union[1].name === 'Array' && type.union[1].templates[0].name === type.union[0].name)
+      return `[]${type.union[0].name}`; // an example of this is [string]|[Array]<[string]>
+    else if (type.union[0].name === 'path')
+      // we don't support path, but we know it's usually an object on the other end, and we expect
+      // the dotnet folks to use [NameOfTheObject].LoadFromPath(); method which we can provide separately
+      return translateType(type.union[1], parent, generateNameCallback);
+    else if (type.expression === '[float]|"raf"')
+      return `interface{}`; // hardcoded because there's no other way to denote this
+    else if (type.expression === '[string]|[RegExp]')
+      return "interface{}"
+    if (type.expression === "[string]|[RegExp]|[function]([URL]):[boolean]")
+      return "interface{}"
+    return null;
+  }
+
+  const removePointer = i => i.replace(/^\*(.*)/g, "$1")
+  if (type.name === 'Array') {
+    if (type.templates.length != 1)
+      throw new Error(`Array (${type.name} from ${parent.name}) has more than 1 dimension. Panic.`);
+
+    let innerType = translateType(type.templates[0], parent, generateNameCallback);
+    return `[]${removePointer(innerType)}`;
+  }
+
+  if (type.name === 'Object') {
+    // take care of some common cases
+    // TODO: this can be genericized
+    if (type.templates && type.templates.length == 2) {
+      // get the inner types of both templates, and if they're strings, it's a keyvaluepair string, string,
+      let keyType = translateType(type.templates[0], parent, generateNameCallback);
+      let valueType = translateType(type.templates[1], parent, generateNameCallback);
+      return `map[${removePointer(keyType)}]${removePointer(valueType)}`;
+    }
+
+    if ((type.name === 'Object')
+      && !type.properties
+      && !type.union) {
+      return 'interface{}';
+    }
+    // this is an additional type that we need to generate
+    let objectName = generateNameCallback(type);
+    if (objectName === 'Object') {
+      throw new Error('Object unexpected');
+    } else if (type.name === 'Object') {
+      registerAdditionalType(objectName, type);
+    }
+    return `*${objectName}`;
+  }
+
+  if (type.name === 'Map') {
+    if (type.templates && type.templates.length == 2) {
+      // we map to a dictionary
+      let keyType = translateType(type.templates[0], parent, generateNameCallback);
+      let valueType = translateType(type.templates[1], parent, generateNameCallback);
+      return `Dictionary<${keyType}, ${valueType}>`;
+    } else {
+      throw 'Map has invalid number of templates.';
+    }
+  }
+
+  if (type.name === 'function') {
+    if (type.expression === '[function]' || !type.args)
+      return 'interface{}'; // super simple mapping
+
+    let argsList = '';
+    if (type.args) {
+      let translatedCallbackArguments = type.args.map(t => translateType(t, parent, generateNameCallback));
+      if (translatedCallbackArguments.includes(null))
+        throw new Error('There was an argument we could not parse. Aborting.');
+
+      argsList = translatedCallbackArguments.join(', ');
+    }
+
+    if (!type.returnType) {
+      // this is an Action
+      return `func(${argsList})`;
+    } else {
+      let returnType = removePointer(translateType(type.returnType, parent, generateNameCallback));
+      if (returnType == null)
+        throw new Error('Unexpected null as return type.');
+      return `func(${argsList}) ${returnType}`;
+    }
+  }
+
+  // there's a chance this is a name we've already seen before, so check
+  // this is also where we map known types, like boolean -> bool, etc.
+  let name = classNameMap.get(type.name) || type.name;
+  return `${name}`;
+}
+
+/**
+ *
+ * @param {string} typeName
+ * @param {Documentation.Type} type
+ */
+function registerAdditionalType(typeName, type) {
+  if (['object', 'string', 'int'].includes(typeName))
+    return;
+
+  let potentialType = additionalTypes.get(typeName);
+  if (potentialType) {
+    console.log(`Type ${typeName} already exists, so skipping...`);
+    return;
+  }
+
+  additionalTypes.set(typeName, type);
+}
